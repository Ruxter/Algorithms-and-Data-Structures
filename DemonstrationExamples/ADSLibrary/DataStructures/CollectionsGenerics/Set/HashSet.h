#pragma once
#include <memory>
#include <iostream>

namespace ADSLibrary
{
	namespace DataStructures
	{
		namespace CollectionsGenerics
		{
			namespace Set
			{
				/**
				* Tøída reprezentující prvek ve množinì
				*/
				template <typename T>
				struct HashNode {

					T Key;
					HashNode * Next;

					HashNode(T Key) {
						this->Key = Key;
						this->Next = nullptr;
					}

					T getKey() {
						return this->Key;
					}

					HashNode* getNext()
					{
						return this->Next;
					}
				};

				template <class T> class HashSet
				{
				public:
					/**
					* Konstruktor
					*/
					HashSet();

					/**
					* Destruktor
					*/
					~HashSet();

					/**
					* Metoda pro vložení prvku do slovníku
					* @param Key klíè vkládaného prvku, tento klíè se pøed vložením zhašuje
					*/
					void Add(const T& Key) const;

					/**
					* Metoda pro získání hodnoty HashNode podle daného klíèe
					* @param Key klíè, podle kterého se vyhledává prvek
					* @return vrací generickou hodnotu HashNode
					*/
					bool Contains(const T& Key);

					/**
					* Metoda pro odebrání prvku ze slovníku
					* @param Key klíè, dle kterého se odebírá
					*/
					void Remove(const T& Key);

					/**
					* Metoda pro odspoèítání prvkù v množinì
					* @return vrací poèet prvkù
					*/
					int Count();

					/**
					* Metoda pro zjištìní, zda je množina prázdná
					* @return vrací true pokud je prázdná, jinak false
					*/
					bool IsEmpty();

					/**
					* Metoda pro prùnik dvou množin. Postupnì porovnává, zda obì množiny obsahují danou hodnotu. Pøeskakuje uzly NULL a prochází všechny uzly v dané pøihrádce hašovací tabulky.
					* @param set je množina, se kterou se provádí prùnik
					* @param newTable je nová výstupní množina s prùnikem
					*/
					void Intersect(const HashSet* set, const HashSet* newTable);

					/**
					* Metoda pro sjednocení dvou množin. Projde napøed jednu, pak druhou množinu a vloží do nové výstupní.
					* @param set je množina, se kterou se provádí prùnik
					* @param newTable je nová výstupní množina s prùnikem
					*/
					void Union(const HashSet* set, const HashSet* newTable);

					/**
					* Pomocná metoda pro výpis
					*/
					void Report();

				private:

					/**
					* Promìnná reprezentující poèet pøihrádek v hashtable
					*/
					int m_size = 128;

					/**
					* Metoda pro zhašování klíèe prvku
					* @param Key hašovaný klíè
					* @return vrací zhašovaný klíè
					*/
					int HashFunc(const T& Key) const;

					HashNode<T>** table;
				};

				template<typename T> HashSet<T>::HashSet()
				{
					table = new HashNode<T>*[m_size];
					for (int i = 0; i < m_size; i++)
						table[i] = nullptr;
				}

				template<typename T> HashSet<T>::~HashSet()
				{
					for (int i = 0; i < m_size; ++i)
					{
						HashNode<T>* entry = table[i];
						while (entry != nullptr)
						{
							HashNode<T>* prev = entry;
							entry = entry->Next;
							delete prev;
						}
					}
					delete[] table;
				}

				template<typename T> int HashSet<T>::HashFunc(const T& Key) const
				{
					return std::hash<T>()(Key) % m_size;
				}

				template<typename T> void HashSet<T>::Add(const T& Key) const
				{
					int hash = HashFunc(Key);
					HashNode<T> *prev = nullptr;
					HashNode<T> *entry = table[hash];

					while (entry != nullptr && entry->getKey() != Key)
					{
						prev = entry;
						entry = entry->getNext();
					}

					if (entry == nullptr)
					{
						entry = new HashNode<T>(Key);
						if (prev == nullptr) table[hash] = entry;
						else prev->Next = entry;
					}
					else entry->Key = Key;
				}

				template<typename T> void HashSet<T>::Remove(const T& Key)
				{
					int hash = HashFunc(Key);
					if (table[hash] != NULL) {
						HashNode<T>* prevEntry = nullptr;
						HashNode<T>* entry = table[hash];
						while (entry->getNext() != NULL && entry->getKey() != Key) {
							prevEntry = entry;
							entry = entry->getNext();
						}
						if (entry->getKey() == Key) {
							if (prevEntry == nullptr) {
								HashNode<T>* nextEntry = entry->getNext();
								delete entry;
								table[hash] = nextEntry;
							}
							else {
								HashNode<T>* next = entry->getNext();
								delete entry;
								prevEntry->Next = next;
							}
						}
					}
				}

				template<typename T> bool HashSet<T>::Contains(const T& Key)
				{
					int hash = HashFunc(Key);
					HashNode<T>* entry = table[hash];
					while (entry != nullptr)
					{
						if (entry->Key == Key)
						{
							return true;
						}
						entry = entry->Next;
					}
					return false;
				}

				template<typename T> int HashSet<T>::Count()
				{
					int count = 0;
					HashNode<T>* entry = table[0];
					for (int i = 0; i < m_size; i++)
					{
						entry = table[i];
						while (entry != nullptr)
						{
							count++;
							entry = entry->Next;
						}
					}
					return count;
				}

				template<typename T> bool HashSet<T>::IsEmpty()
				{
					bool isEmpty = true;
					for (int i = 0; i < m_size; i++)
					{
						if (table[i] != nullptr) 
						{
							isEmpty = false;
							break;
						}
					}
					return isEmpty;
				}

				template<typename T> void HashSet<T>::Intersect(const HashSet* set, const HashSet* newTable)
				{
					HashNode<T>* entry = nullptr;
					for(int i = 0; i < m_size; i++)
					{
						for (int j = 0; j < set->m_size; j++)
						{
							if (table[i] != nullptr)
							{
								if (set->table[j] == nullptr) continue;
								if(set->table[j]->getKey() == table[i]->getKey())
								{
									newTable->Add(table[i]->getKey());
									entry = table[i];
									while (entry != nullptr)
									{
										newTable->Add(entry->getKey());
										entry = entry->Next;
									}
									entry = set->table[j];
									while (entry != nullptr)
									{
										newTable->Add(entry->getKey());
										entry = entry->Next;
									}
									break;
								}
							}
						}
					}
				}

				template<typename T> void HashSet<T>::Union(const HashSet* set, const HashSet* newTable)
				{
					HashNode<T>* entry = table[0];
					for (int i = 0; i < m_size; i++)
					{
						entry = table[i];
						while (entry != nullptr)
						{
							newTable->Add(entry->getKey());
							entry = entry->Next;
						}
					}
					entry = set->table[0];
					for (int j = 0; j < m_size; j++)
					{
						entry = set->table[j];
						while (entry != nullptr)
						{
							newTable->Add(entry->getKey());
							entry = entry->Next;
						}
					}
				}

				template<typename T> void HashSet<T>::Report()
				{
					for (int i = 0; i < m_size; i++)
					{
						if (table[i] != nullptr) std::cout << table[i]->getKey() << " NEXT:" << table[i]->getNext() << std::endl;
					}
				}
				
			}
		}
	}
}
